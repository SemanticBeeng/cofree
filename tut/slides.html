<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif', 'Helvetica'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz', 'Gill Sans';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono', 'Consolas', 'Courier New'; }
    </style>
  </head>
  <body>
    <textarea id="source">

```tut:invisible
import scalaz._, Scalaz._, scalaz.effect.IO
import atto._, Atto._
import doobie.imports._

val pos: Parser[Int] = {
  import Trampoline._
  import Parser._
  import Parser.Internal._
  new Parser[Int] {
    override def toString = "pos"
    def apply[R](st0: State, kf: Failure[R], ks: Success[Int,R]): TResult[R] =
      suspend(ks(st0,st0.pos))
  }
}
```

class: center, middle

# Fun & Games with Fix, Cofree, and Doobie!
Rob Norris • `@tpolecat` • Gemini Observatory

???

- I'm Rob, I'm from Portland, first time in Montréal
- For my day job I write software for big telescopes, but I also work on some open-source projects in support of typeful, pure functional programming in Scala. That's what I'm interested in.
- So today I want to talk about some odds and ends that I think are interesting, and we'll see if you find them interesting to.

---

# Goals

1. Gain an intuition about some simple recursive types.
2. Gain some confidence pushing on code to see what happens.
3. Learn how boring doobie is.
4. Do not panic.

???

1. --- that's the main point of the talk. These types seem to be pretty well known in the Haskell community but not so much among Scala programmers, and they're interesting and worth knowing about.
2. --- so, this is something I mention from time to time when I give talks and people ask me to say more about it, so I'll try to do that as well.
3. --- Ok, so this is ostensibly a talk about database programming with doobie, which is a library I work on, but really it's a sketch of some things we can do with these interesting types and the tools we have as functional programmers. The database stuff ends up being really easy so it's kind of incidental.
4. --- Recursion is always mind-blowing at first. Everybody struggles with recursive functions and recursive data types, and today we're going to talk about recursion at the type level, which may be new to a lot of you. So remain calm, this can be hard to grasp. So I'm going to try to approach it very gradually. If it ends up being too slow for you, I apologize; if it's too fast I also apologize. But please stop me if you have questions.

Ok so let's look at a recursive data type.

---

# Recursive Data

A recursive data type for professors and their Ph.D. students.

```tut:silent
case class Prof(
  name: String,
  year: Int,
  students: List[Prof]
)
```

<img align=right src="prof.png"/>


???

- ...
- So the problem I want to talk about is how to store this in a relational database. So how do I save this thing to a database and read it back?

---

# Recursive Data

A recursive data type for professors and their Ph.D. students.

```tut:silent
case class Prof(
  name: String,
  year: Int,
  students: List[Prof]
)
```

Natural SQL representation:

<img align=right src="prof.png"/>

```sql
CREATE TABLE prof (
  id     INTEGER IDENTITY,
  parent INTEGER     NULL,
  name   VARCHAR NOT NULL,
  year   INTEGER NOT NULL,
  FOREIGN KEY(parent) REFERENCES prof(id)        
)
```

???

- Here's how you normally want to do it. You have the child refer to its parent, so the relationship is inverted.
- But before we get to that we need to talk about how we're going to represent the id on the Scala side.
- Ok so here's one possibility.

---

# Recursive Data

A recursive data type for professors and their Ph.D. students.

```tut:silent
case class Prof(
  id : Int @@ Prof,
  name: String,
  year: Int,
  students: List[Prof]
)
```

Natural SQL representation.

<img align=right src="prof.png"/>

```sql
CREATE TABLE prof (
  id     INTEGER IDENTITY,
  parent INTEGER     NULL,
  name   VARCHAR NOT NULL,
  year   INTEGER NOT NULL,
  FOREIGN KEY(parent) REFERENCES prof(id)        
)
```

???

- So we would probably use a tagged type or something to store this, but just for simplicity I'm going to use a plan `Int`.
- Also going to get rid of the table definition for now.

---

# Recursive Data

A recursive data type for professors and their Ph.D. students.

```tut:silent
case class Prof(
  id : Int,
  name: String,
  year: Int,
  students: List[Prof]
)
```

<img align=right src="prof.png"/>

???

- Ok so what's wrong with this representatoin for IDs? (new objects)

---

# Recursive Data

A recursive data type for professors and their Ph.D. students.

```tut:silent
case class Prof(
  id : Option[Int],
  name: String,
  year: Int,
  students: List[Prof]
)
```

<img align=right src="prof.png"/>

???

Ok is this any better? Maybe a little bit, but I think it's irritating because you tend to have three cases:

1. it's new, and we know it's new
2. it's from the database so we know it has an id
3. we don't care about ids

And this encoding is irritating in all three cases, so I don't like it.

So a way to make the id less invasive is to externalize it.

---

# Recursive Data

A recursive data type for professors and their Ph.D. students.

```tut:silent
case class Prof(
  name: String,
  year: Int,
  students: List[Prof]
)

type IdProf = (Int, Prof)
```

<img align=right src="prof.png"/>

???

- so ...
- but the problem now is that the children don't have ids, right? So we have to do this:


---

# Recursive Data

A recursive data type for professors and their Ph.D. students.

```tut:silent
case class Prof(
  name: String,
  year: Int,
  students: List[(Int, Prof)]
)

type IdProf = (Int, Prof)
```

<img align=right src="prof.png"/>

???

- ... Which defeats the purpose of externalizing the ids … the whole point was to not have to talk about them in the model.

So let's try something else. Let's parameterize it on the child type.

---

# Recursive Data

A ~~recursive~~ data type for professors and their Ph.D. students.

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent:fail
type Prof   = ProfF[ProfF]
type IdProf = (Int, ProfF[(Int, ProfF)])
```

<img align=right src="prof.png"/>

???

- ok so the data type isn't recursive anymore
- And I'm going to call this `ProfF` just to distinguish it from our old `Prof`, so now we can just say ...
- right? no, because ProfF has a type parameter

---

# Recursive Data

A ~~recursive~~ data type for professors and their Ph.D. students.

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent:fail
type Prof   = ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[
type IdProf = (Int, ProfF[(Int, ProfF[(Int, ProfF[(Int, ProfF[(Int, ProfF[(Int, ProfF[(Int, ProfF[(Int, ProfF[(Int, 
```

<img align=right src="prof.png"/>

???

- so this doesn't work because the types are infinite



---

# Recursive Data

A ~~recursive~~ data type for professors and their Ph.D. students.

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent:fail
type Prof   = ProfF[Prof]
type IdProf = (Int, ProfF[IdProf])
```

<img align=right src="prof.png"/>

???

- what if we make the type aliases self-referential? 
- ok? no. doesn't compile
- type aliases can't be recursive. but **classes** can ...

---

# Recursive Data

A ~~recursive~~ data type for professors and their Ph.D. students.

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent
case class Prof(value: ProfF[Prof])
case class IdProf(id: Int, value: ProfF[IdProf])
```

???

- So what if we make these case classes? Does this work?
- YES! We could claim victory here because this actually does what we want.
- But this is functional programming and we like abstraction, so let's push on this a little it and see if we can generalize it a little bit.

---

# Recursive Data

A ~~recursive~~ data type for professors and their Ph.D. students.

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent:fail
case class Prof[F[_]](value: F[Prof])
case class IdProf[F[_]](id: Int, value: F[IdProf])
```

???

- Ok, so there's nothing here's that's specific to ProfF, so let's factor that out.
- But this doesn't compile because `Prof` needs a type argument, which is ... `F` right?

---

# Recursive Data

A ~~recursive~~ data type for professors and their Ph.D. students.

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent
case class Prof[F[_]](value: F[Prof[F]])
case class IdProf[F[_]](id: Int, value: F[IdProf[F]]) 
```

???

- We also note that this doesn't depend on the id being an `Int` so let's factor that out too.

---

# Recursive Data

A ~~recursive~~ data type for professors and their Ph.D. students.

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent
case class Prof[F[_]](value: F[Prof[F]])
case class IdProf[F[_], A](id: A, value: F[IdProf[F, A]])
```

???

- and we had to add the `A` to the type argument here since `IdProf` now has two type parameters.
- Ok, so what do we have now? We have two recursive types that are totally generic; the first one can make any `F` recursive, and the second can make any `F` recursive *and* annotate each value with some arbitrary label.
- It turns out these are well-known types.

---

# Recursive Data

A ~~recursive~~ data type for professors and their Ph.D. students.

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent
case class Fix[F[_]](unfix: F[Fix[F]])
case class Cofree[F[_], A](head: A, tail: F[Cofree[F, A]])
```

- the first is ...
- the second is ...
- and I'll mention here that 

---

# Recursive Data

A ~~recursive~~ data type for professors and their Ph.D. students.

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent
case class Fix[F[_]](unfix: F[Fix[F]])
case class Cofree[F[_], A](head: A, tail: F[Cofree[F, A]])
```

```tut:silent
type Prof   = Fix[ProfF]
type IdProf = Cofree[ProfF, Int]
```

---

# Recursive Data

```tut:silent
case class Prof(name: String, year: Int, students: List[Prof])


val p: Prof = 
  Prof("Hilbert", 1885, List(
    Prof("Ackermann", 1925, Nil),
    Prof("Curry", 1930, Nil),
    Prof("Weyl", 1908, List(
      Prof("Mac Lane", 1934, List(
        Prof("Howard", 1956, Nil),
        Prof("Awodey", 1997, Nil)
      ))
    ))
 ))
```
<img align=right src="prof.png"/>



---

# Recursive Data

```tut:silent
case class ProfF[A](name: String, year: Int, students: List[A])
type Prof = Fix[ProfF]

val p: Prof = 
  Fix(ProfF("Hilbert", 1885, List(
    Fix(ProfF("Ackermann", 1925, Nil)),
    Fix(ProfF("Curry", 1930,Nil)),
    Fix(ProfF("Weyl", 1908, List(
      Fix(ProfF("Mac Lane", 1934, List(
        Fix(ProfF("Howard", 1956, Nil)),
        Fix(ProfF("Awodey", 1997, Nil))
      ))))
    )))
  ))
```
<img align=right src="prof.png"/>


---

# Recursive Data

```tut:silent
case class ProfF[A](name: String, year: Int, students: List[A])
type IdProf = Cofree[ProfF, Int]

val p: IdProf = 
  Cofree(1, ProfF("Hilbert", 1885, List(
    Cofree(2, ProfF("Ackermann", 1925, Nil)),
    Cofree(3, ProfF("Curry", 1930,Nil)),
    Cofree(4, ProfF("Weyl", 1908, List(
      Cofree(5, ProfF("Mac Lane", 1934, List(
        Cofree(6, ProfF("Howard", 1956, Nil)),
        Cofree(7, ProfF("Awodey", 1997, Nil))
      ))))
    )))
  ))
```
<img align=right src="idprof.png"/>

---

class: center, middle

# Intermezzo

---

# Parse Positions

```tut:silent
case class ProfF[A](name: String, year: Int, students: List[A])

val data =
  """|Simeon Denis Poisson, 1800
     |  Gustav Peter Lejeune Dirichlet, 1827
     |    Rudolf Otto Sigismund Lipschitz, 1853
     |      C. Felix (Christian) Klein, 1868
     |        William Edward Story, 1875
     |          Solomon Lefschetz, 1911
     |            Albert William Tucker, 1932
     |              Marvin Lee Minsky, 1954
     |                Gerald Jay Sussman, 1973
     |                  Guy Lewis Steele, 1980
     |                    Philip Lee Wadler, 1984
     |        C. L. Ferdinand (Carl Louis) Lindemann, 1873
     |          David Hilbert, 1885
     |            Wilhelm Ackermann, 1925
     |            Haskell Curry, 1930
     |            Hermann Weyl, 1908
     |              Saunders Mac Lane, 1934
     |                Steven Awodey, 1997
     |                William Howard, 1956
     |""".stripMargin


```

---

# Parse Positions

```tut:invisible
case class ProfF[A](name: String, year: Int, students: List[A]) {
  override def toString = s"ProfF($name, $year, «${students.length}»)"
}
```

```tut:silent
def prof(n: Int): Parser[Fix[ProfF]] =
  for {
    _    <- manyN(n, char(' '))     // skip 'n' spaces
    name <- stringOf(notChar(','))  // read up to a comma
    _    <- token(char(','))        // skip comma and following space
    year <- int                     // read an int
    _    <- char('\n')              // skip a newline
    ss   <- many(prof(n + 2))       // recursively read more at indent + 2
  } yield Fix(ProfF(name, year, ss))
```


---

# Parse Positions

```tut:silent
def prof(n: Int): Parser[Fix[ProfF]] =
  for {
    _    <- manyN(n, char(' '))     // skip 'n' spaces
    name <- stringOf(notChar(','))  // read up to a comma
    _    <- token(char(','))        // skip comma and following space
    year <- int                     // read an int
    _    <- char('\n')              // skip a newline
    ss   <- many(prof(n + 2))       // recursively read more at indent + 2
  } yield Fix(ProfF(name, year, ss))
```

```tut
prof(0).parseOnly(data).option
```

---

# Parse Positions

```tut:invisible
def drawFix(fa: Fix[ProfF]): Unit = {
  def go(fa: Fix[ProfF], indent: Int = 0): Unit = { 
    print(" " * indent)
    println(fa.unfix)
    fa.unfix.students.foreach(go(_, indent + 1))
  }
  go(fa, 0)
}
```

```tut
prof(0).parseOnly(data).option.foreach(drawFix)
```


---

# Parse Positions

```tut:silent
def prof(n: Int): Parser[Fix[ProfF]] =
  for {

    _    <- manyN(n, char(' '))     // skip 'n' spaces
    name <- stringOf(notChar(','))  // read up to a comma
    _    <- token(char(','))        // skip comma and following space
    year <- int                     // read an int
    _    <- char('\n')              // skip a newline
    ss   <- many(prof(n + 2))       // recursively read more at indent + 2

  } yield Fix(ProfF(name, year, ss))
```

---

# Parse Positions

```tut:silent
def posProf(n: Int): Parser[Cofree[ProfF, (Int, Int)]] =
  for {
    p0   <- pos
    _    <- manyN(n, char(' '))     // skip 'n' spaces
    name <- stringOf(notChar(','))  // read up to a comma
    _    <- token(char(','))        // skip comma and following space
    year <- int                     // read an int
    _    <- char('\n')              // skip a newline
    ss   <- many(posProf(n + 2))    // recursively read more at indent + 2
    p1   <- pos
  } yield Cofree((p0, p1), ProfF(name, year, ss))
```

---

# Parse Positions

```tut:silent
def posProf(n: Int): Parser[Cofree[ProfF, (Int, Int)]] =
  for {
    p0   <- pos
    _    <- manyN(n, char(' '))     // skip 'n' spaces
    name <- stringOf(notChar(','))  // read up to a comma
    _    <- token(char(','))        // skip comma and following space
    year <- int                     // read an int
    _    <- char('\n')              // skip a newline
    ss   <- many(posProf(n + 2))    // recursively read more at indent + 2
    p1   <- pos
  } yield Cofree((p0, p1), ProfF(name, year, ss))
```

```tut
posProf(0).parseOnly(data).option
```

---

# Parse Positions

```tut:invisible
def drawCofree[A](fa: Cofree[ProfF, A]): Unit = {
  def go(fa: Cofree[ProfF, A], indent: Int = 0): Unit = { 
    print(" " * indent)
    println(fa.head + " :< " + fa.tail)
    fa.tail.students.foreach(go(_, indent + 1))
  }
  go(fa, 0)
}
```

```tut
posProf(0).parseOnly(data).option.foreach(drawCofree)
```

---

class: center, middle

# Games

---

# So Why the F?

```tut:silent
case class ProfF[A](name: String, year: Int, students: List[A])
```

`ProfF` is a functor. This means we can map over it. 

```tut:silent
implicit val PersonFunctor: Functor[ProfF] =
  new Functor[ProfF] {
    def map[A, B](fa: ProfF[A])(f: A => B): ProfF[B] =
      fa.copy(students = fa.students.map(f))
  }
```

Thus.

```tut
val ps = ProfF("Bob", 1976, List("foo", "bar"))
ps.map(s => s.length)
```

---

# But wait, there's more!

```tut:silent
case class ProfF[A](name: String, year: Int, students: List[A])
```

`ProfF` is a *traversable* functor. This means we can sequence it.

```tut:silent
implicit val PersonTraverse: Traverse[ProfF] =
  new Traverse[ProfF] {
    def traverseImpl[G[_]: Applicative, A, B](fa: ProfF[A])(f: A => G[B]): G[ProfF[B]] =
      fa.students.traverse(f).map(ss => fa.copy(students = ss))
  }
```

Thus.

```tut
val p = ProfF("Bob", 1975, List(Option(1), Option(2)))
p.sequence
```

---

# (small digression)

Because "map and then sequence" is so common, we provide `traverse` which does them in one step.

```scala
fa.map(f).sequence <~> fa.traverse(f) // (1) definition of traverse
```

And we can find another identity by equational reasoning.

```scala

fa          <~> fa.map(identity)          // (2) the functor law

fa.sequence <~> fa.map(identity).sequence // by (2) above

fa.sequence <~> fa.traverse(identity)     // by (1) above
```

So when you're working with traversable functors it's nice to know both of those substitutions.


---

class: center, middle

# Can we do some SQL now?


---

# Get your doobie on

```tut:silent
// a transactor abstracts over connection pools and io-effect types
val xa = DriverManagerTransactor[IO]("org.h2.Driver", "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1", "sa", "")

// a program to create the schema
val create: ConnectionIO[Int] =
  sql"""
    CREATE TABLE prof (
      id     INTEGER IDENTITY,
      parent INTEGER     NULL,
      name   VARCHAR NOT NULL,
      year   INTEGER NOT NULL,
      FOREIGN KEY(parent) REFERENCES prof(id)        
    );
  """.update.run
```

Let's init the database.

```tut
create.transact(xa).unsafePerformIO
sql"select id from prof".query[Int].list.transact(xa).unsafePerformIO
```


---

# Insert a Tree

```tut:silent
def insertNode(op: Option[Int], p: ProfF[_]): ConnectionIO[Int] =
  sql"""
    INSERT INTO prof (parent, name, year)
    VALUES ($op, ${p.name}, ${p.year})
  """.update.withUniqueGeneratedKeys("id")
```

---

# Insert a Tree

```tut:silent
def insertNode(op: Option[Int], p: ProfF[_]): ConnectionIO[Int] =
  sql"""
    INSERT INTO prof (parent, name, year)
    VALUES ($op, ${p.name}, ${p.year})
  """.update.withUniqueGeneratedKeys("id")

def insertTree(fp: Fix[ProfF], op: Option[Int]): ConnectionIO[Cofree[ProfF, Int]] =
  for {
    h <- insertNode(op, fp.unfix)       // ConnectionIO[Int] 
    t <- fp.unfix                       // ProfF[Fix[ProfF]] 
           .map(insertTree(_, Some(h))) // ProfF[ConnectionIO[Cofree[ProfF, Int]]]
           .sequence                    // ConnectionIO[ProfF[Cofree[ProfF, Int]]]
  } yield Cofree(h, t) 
```

---

# Insert a Tree

```tut:silent
def insertNode(op: Option[Int], p: ProfF[_]): ConnectionIO[Int] =
  sql"""
    INSERT INTO prof (parent, name, year)
    VALUES ($op, ${p.name}, ${p.year})
  """.update.withUniqueGeneratedKeys("id")

def insertTree(fp: Fix[ProfF], op: Option[Int]): ConnectionIO[Cofree[ProfF, Int]] =
  for {
    h <- insertNode(op, fp.unfix)
    t <- fp.unfix
           .traverse(insertTree(_, Some(h))) // same as map + sequence
  } yield Cofree(h, t) 
```

---

# Insert a Tree

```tut:invisible
// redefine due to shadowing
case class ProfF[A](name: String, year: Int, students: List[A]) {
  override def toString = s"ProfF($name, $year, «${students.length}»)"
}
implicit val PersonTraverse: Traverse[ProfF] =
  new Traverse[ProfF] {
    def traverseImpl[G[_]: Applicative, A, B](fa: ProfF[A])(f: A => G[B]): G[ProfF[B]] =
      fa.students.traverse(f).map(ss => fa.copy(students = ss))
  }
```

```tut:silent
def insertNode(op: Option[Int], p: ProfF[_]): ConnectionIO[Int] =
  sql"""
    INSERT INTO prof (parent, name, year)
    VALUES ($op, ${p.name}, ${p.year})
  """.update.withUniqueGeneratedKeys("id")

def insertTree(fp: Fix[ProfF], op: Option[Int]): ConnectionIO[Cofree[ProfF, Int]] =
  for {
    h <- insertNode(op, fp.unfix)
    t <- fp.unfix.traverse(insertTree(_, Some(h)))
  } yield Cofree(h, t) 
```

---

# Insert a Tree

```tut:invisible
// redefine due to shadowing

def prof(n: Int): Parser[Fix[ProfF]] =
  for {
    _    <- manyN(n, char(' '))   
    name <- stringOf(notChar(','))
    _    <- token(char(','))      
    year <- int                   
    _    <- char('\n')            
    ss   <- many(prof(n + 2))     
  } yield Fix(ProfF(name, year, ss))

def ioDrawCofree[F[_]: Traverse, A](fa: Cofree[F, A], indent: Int = 0): IO[Unit] = 
  for {
    _ <- IO(print(" " * indent))
    _ <- IO(println(fa.head + " :< " + fa.tail))
    _ <- fa.tail.traverse(ioDrawCofree(_, indent + 1))
  } yield ()
```

```tut
val p = prof(0).parseOnly(data).option.get // yolo
val io = insertTree(p, None).transact(xa).flatMap(c => ioDrawCofree(c))
io.unsafePerformIO
```

---

# Insert a Tree

```tut
io.unsafePerformIO
```

---

# And now read it back.

```tut:silent
def readNode(id: Int): ConnectionIO[ProfF[Int]] =
  for {
    d  <- sql"SELECT name, year FROM prof WHERE id = $id".query[(String, Int)].unique
    ss <- sql"SELECT id FROM prof WHERE parent = $id".query[Int].list
  } yield ProfF(d._1, d._2, ss)
```
---


# And now read it back.

```tut:silent
def readNode(id: Int): ConnectionIO[ProfF[Int]] =
  for {
    d  <- sql"SELECT name, year FROM prof WHERE id = $id".query[(String, Int)].unique
    ss <- sql"SELECT id FROM prof WHERE parent = $id".query[Int].list
  } yield ProfF(d._1, d._2, ss)

def readTree(id: Int): ConnectionIO[Cofree[ProfF, Int]] =
  readNode(id).flatMap { pi =>
    pi.map(readTree)      // ProfF[ConnectionIO[Cofree[ProfF, Int]]]
      .sequence           // ConnectionIO[ProfF[Cofree[ProfF, Int]]]
      .map(Cofree(id, _)) // ConnectionIO[Cofree[ProfF, Int]]
  }
```

---

# And now read it back.

```tut:silent
def readNode(id: Int): ConnectionIO[ProfF[Int]] =
  for {
    d  <- sql"SELECT name, year FROM prof WHERE id = $id".query[(String, Int)].unique
    ss <- sql"SELECT id FROM prof WHERE parent = $id".query[Int].list
  } yield ProfF(d._1, d._2, ss)

def readTree(id: Int): ConnectionIO[Cofree[ProfF, Int]] =
  readNode(id).flatMap { pi =>
    pi.traverse(readTree)
      .map(Cofree(id, _))
  }
```

---

# And now read it back.

```tut:silent
def readNode(id: Int): ConnectionIO[ProfF[Int]] =
  for {
    d  <- sql"SELECT name, year FROM prof WHERE id = $id".query[(String, Int)].unique
    ss <- sql"SELECT id FROM prof WHERE parent = $id".query[Int].list
  } yield ProfF(d._1, d._2, ss)

def readTree(id: Int): ConnectionIO[Cofree[ProfF, Int]] =
  readNode(id).flatMap(_.traverse(readTree).map(Cofree(id, _)))
```


---

# (another digression)

```tut:silent
// our original method for reading a tree
def readTree(id: Int): ConnectionIO[Cofree[ProfF, Int]] =
  readNode(id).flatMap(_.traverse(readTree).map(Cofree(id, _)))
```


---

# (another digression)

```tut:silent
// factor out the function we're calling
def readTree(id: Int)(f: Int => ConnectionIO[ProfF[Int]]): ConnectionIO[Cofree[ProfF, Int]] =
  f(id).flatMap(_.traverse(readTree(_)(f)).map(Cofree(id, _)))
```


---

# (another digression)

```tut:silent
// factor out the monad
def readTree[M[_]: Monad](id: Int)(f: Int => M[ProfF[Int]]): M[Cofree[ProfF, Int]] =
  f(id).flatMap(_.traverse(readTree(_)(f)).map(Cofree(id, _)))
```


---

# (another digression)

```tut:silent
// factor out the traversable functor
def readTree[M[_]: Monad, F[_]: Traverse](id: Int)(f: Int => M[F[Int]]): M[Cofree[F, Int]] =
  f(id).flatMap(_.traverse(readTree(_)(f)).map(Cofree(id, _)))
```


---

# (another digression)

```tut:silent
// factor out the Int
def readTree[M[_]: Monad, F[_]: Traverse, A](a: A)(f: A => M[F[A]]): M[Cofree[F, A]] =
  f(a).flatMap(_.traverse(readTree(_)(f)).map(Cofree(a, _)))
```


---

# (another digression)

```tut:silent
// we now have a generic monadic unfold into cofree
def unfoldCM[M[_]: Monad, F[_]: Traverse, A](a: A)(f: A => M[F[A]]): M[Cofree[F, A]] =
  f(a).flatMap(_.traverse(unfoldCM(_)(f)).map(Cofree(a, _)))
```


---

# (another digression)

```tut:silent
// we now have a generic monadic unfold into cofree
def unfoldCM[M[_]: Monad, F[_]: Traverse, A](a: A)(f: A => M[F[A]]): M[Cofree[F, A]] =
  f(a).flatMap(_.traverse(unfoldCM(_)(f)).map(Cofree(a, _)))

// and we can define readTree in terms of it
// we're using a totally generic corecursive unfold to do database programming, which is kind of cool
def readTree(id: Int): ConnectionIO[Cofree[ProfF, Int]] =
  unfoldCM(id)(readNode)
```

---

# Do it work?

Let's read Hilbert's sub-tree (id = 32).

```tut
val io = readTree(32).transact(xa).flatMap(c => ioDrawCofree(c))
io.unsafePerformIO
```


---

# Review

- We learned about some recursive types.
- We used them to do something useful.
- We did some equational reasoning.
- We were not frightened.

---

class: center, middle

# Thanks!
Code and slides at `tpolecat/cofree` on GitHub

## Questions?

















 </textarea>
    <script src="remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
