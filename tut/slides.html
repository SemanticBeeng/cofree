<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

```tut:invisible
import scalaz._, Scalaz._, scalaz.effect.IO
import atto._, Atto._
import doobie.imports._

val pos: Parser[Int] = {
  import Trampoline._
  import Parser._
  import Parser.Internal._
  new Parser[Int] {
    override def toString = "pos"
    def apply[R](st0: State, kf: Failure[R], ks: Success[Int,R]): TResult[R] =
      suspend(ks(st0,st0.pos))
  }
}
```

class: center, middle

# Fun & Games with Fix, Cofree, and Doobie!
Rob Norris • `@tpolecat` • Gemini Observatory

---

# Goals

1. Gain an intuition about some simple recursive types.
2. Gain some confidence pushing on your types to see what happens.
3. Learn how boring doobie is.
4. Do not panic.

---

# Recursive Data

```tut:silent
case class Prof(
  name: String,
  year: Int,
  students: List[Prof]
)
```
---

# Recursive Data

```tut:silent
case class Prof(
  id : Int @@ Prof,
  name: String,
  year: Int,
  students: List[Prof]
)
```

---

# Recursive Data

```tut:silent
case class Prof(
  id : Int,
  name: String,
  year: Int,
  students: List[Prof]
)
```

---

# Recursive Data

```tut:silent
case class Prof(
  id : Option[Int],
  name: String,
  year: Int,
  students: List[Prof]
)
```

---

# Recursive Data

```tut:silent
case class Prof(
  name: String,
  year: Int,
  students: List[Prof]
)

type IdProf = (Int, Prof)
```

---

# Recursive Data

```tut:silent
case class Prof(
  name: String,
  year: Int,
  students: List[(Int, Prof)]
)

type IdProf = (Int, Prof)
```

---

# Recursive Data

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent:fail
type Prof   = ProfF[ProfF]
type IdProf = (Int, ProfF[(Int, ProfF)])
```

---

# Recursive Data

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent:fail
type Prof   = ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[ProfF[
type IdProf = (Int, ProfF[(Int, ProfF[(Int, ProfF[(Int, ProfF[(Int, ProfF[(Int, ProfF[(Int, ProfF[(Int, ProfF[(Int, 
```

---

# Recursive Data

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent:fail
type Prof   = ProfF[Prof]
type IdProf = (Int, ProfF[IdProf])
```

---

# Recursive Data

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent
case class Prof(value: ProfF[Prof])
case class IdProf(id: Int, value: ProfF[IdProf])
```

---

# Recursive Data

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent
case class Prof[F[_]](value: F[Prof[F]])
case class IdProf[F[_]](id: Int, value: F[IdProf[F]])
```

---

# Recursive Data

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent
case class Prof[F[_]](value: F[Prof[F]])
case class IdProf[F[_], A](id: A, value: F[IdProf[F, A]])
```

---

# Recursive Data

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent
case class Fix[F[_]](value: F[Fix[F]])
case class Cofree[F[_], A](id: A, value: F[Cofree[F, A]])
```

---

# Recursive Data

```tut:silent
case class ProfF[A](
  name: String,
  year: Int,
  students: List[A]
)
```

```tut:silent
case class Fix[F[_]](unfix: F[Fix[F]])
case class Cofree[F[_], A](head: A, tail: F[Cofree[F, A]])
```

```tut:silent
type Prof   = Fix[ProfF]
type IdProf = Cofree[ProfF, Int]
```

---

# Recursive Data

```tut:silent
case class Prof(name: String, year: Int, students: List[Prof])


val p: Prof = 
  Prof("Hilbert", 1885, List(
    Prof("Ackermann", 1925, Nil),
    Prof("Curry", 1930, Nil),
    Prof("Weyl", 1908, List(
      Prof("Mac Lane", 1934, List(
        Prof("Howard", 1956, Nil),
        Prof("Awodey", 1997, Nil)
      ))
    ))
 ))
```



---

# Recursive Data

```tut:silent
case class ProfF[A](name: String, year: Int, students: List[A])
type Prof = Fix[ProfF]

val p: Prof = 
  Fix(ProfF("Hilbert", 1885, List(
    Fix(ProfF("Ackermann", 1925, Nil)),
    Fix(ProfF("Curry", 1930,Nil)),
    Fix(ProfF("Weyl", 1908, List(
      Fix(ProfF("Mac Lane", 1934, List(
        Fix(ProfF("Howard", 1956, Nil)),
        Fix(ProfF("Awodey", 1997, Nil))
      ))))
    )))
  ))
```


---

# Recursive Data

```tut:silent
case class ProfF[A](name: String, year: Int, students: List[A])
type IdProf = Cofree[ProfF, Int]

val p: IdProf = 
  Cofree(1, ProfF("Hilbert", 1885, List(
    Cofree(2, ProfF("Ackermann", 1925, Nil)),
    Cofree(3, ProfF("Curry", 1930,Nil)),
    Cofree(4, ProfF("Weyl", 1908, List(
      Cofree(5, ProfF("Mac Lane", 1934, List(
        Cofree(6, ProfF("Howard", 1956, Nil)),
        Cofree(7, ProfF("Awodey", 1997, Nil))
      ))))
    )))
  ))
```

---

class: center, middle

# Intermezzo

---

# Parse Positions

```tut:silent
case class ProfF[A](name: String, year: Int, students: List[A])

val data =
  """|Simeon Denis Poisson, 1800
     |  Gustav Peter Lejeune Dirichlet, 1827
     |    Rudolf Otto Sigismund Lipschitz, 1853
     |      C. Felix (Christian) Klein, 1868
     |        William Edward Story, 1875
     |          Solomon Lefschetz, 1911
     |            Albert William Tucker, 1932
     |              Marvin Lee Minsky, 1954
     |                Gerald Jay Sussman, 1973
     |                  Guy Lewis Steele, 1980
     |                    Philip Lee Wadler, 1984
     |        C. L. Ferdinand (Carl Louis) Lindemann, 1873
     |          David Hilbert, 1885
     |            Wilhelm Ackermann, 1925
     |            Haskell Curry, 1930
     |            Hermann Weyl, 1908
     |              Saunders Mac Lane, 1934
     |                Steven Awodey, 1997
     |                William Howard, 1956
     |""".stripMargin


```

---

# Parse Positions

```tut:invisible
case class ProfF[A](name: String, year: Int, students: List[A]) {
  override def toString = s"ProfF($name, $year, «${students.length}»)"
}
```

```tut:silent
def prof(n: Int): Parser[Fix[ProfF]] =
  for {
    _    <- manyN(n, char(' '))     // skip 'n' spaces
    name <- stringOf(notChar(','))  // read up to a comma
    _    <- token(char(','))        // skip comma and following space
    year <- int                     // read an int
    _    <- char('\n')              // skip a newline
    ss   <- many(prof(n + 2))     // recursively read more at indent + 2
  } yield Fix(ProfF(name, year, ss))
```


---

# Parse Positions

```tut:silent
def prof(n: Int): Parser[Fix[ProfF]] =
  for {
    _    <- manyN(n, char(' '))     // skip 'n' spaces
    name <- stringOf(notChar(','))  // read up to a comma
    _    <- token(char(','))        // skip comma and following space
    year <- int                     // read an int
    _    <- char('\n')              // skip a newline
    ss   <- many(prof(n + 2))     // recursively read more at indent + 2
  } yield Fix(ProfF(name, year, ss))
```

```tut
prof(0).parseOnly(data).option
```

---

# Parse Positions

```tut:invisible
def drawFix(fa: Fix[ProfF]): Unit = {
  def go(fa: Fix[ProfF], indent: Int = 0): Unit = { 
    print(" " * indent)
    println(fa.unfix)
    fa.unfix.students.foreach(go(_, indent + 1))
  }
  go(fa, 0)
}
```

```tut
prof(0).parseOnly(data).option.foreach(drawFix)
```


---

# Parse Positions

```tut:silent
def prof(n: Int): Parser[Fix[ProfF]] =
  for {

    _    <- manyN(n, char(' '))     // skip 'n' spaces
    name <- stringOf(notChar(','))  // read up to a comma
    _    <- token(char(','))        // skip comma and following space
    year <- int                     // read an int
    _    <- char('\n')              // skip a newline
    ss   <- many(prof(n + 2))     // recursively read more at indent + 2

  } yield Fix(ProfF(name, year, ss))
```

---

# Parse Positions

```tut:silent
def posProf(n: Int): Parser[Cofree[ProfF, (Int, Int)]] =
  for {
    p0   <- pos
    _    <- manyN(n, char(' '))     // skip 'n' spaces
    name <- stringOf(notChar(','))  // read up to a comma
    _    <- token(char(','))        // skip comma and following space
    year <- int                     // read an int
    _    <- char('\n')              // skip a newline
    ss   <- many(posProf(n + 2))     // recursively read more at indent + 2
    p1   <- pos
  } yield Cofree((p0, p1), ProfF(name, year, ss))
```

---

# Parse Positions

```tut:silent
def posProf(n: Int): Parser[Cofree[ProfF, (Int, Int)]] =
  for {
    p0   <- pos
    _    <- manyN(n, char(' '))     // skip 'n' spaces
    name <- stringOf(notChar(','))  // read up to a comma
    _    <- token(char(','))        // skip comma and following space
    year <- int                     // read an int
    _    <- char('\n')              // skip a newline
    ss   <- many(posProf(n + 2))     // recursively read more at indent + 2
    p1   <- pos
  } yield Cofree((p0, p1), ProfF(name, year, ss))
```

```tut
posProf(0).parseOnly(data).option
```

---

# Parse Positions

```tut:invisible
def drawCofree[A](fa: Cofree[ProfF, A]): Unit = {
  def go(fa: Cofree[ProfF, A], indent: Int = 0): Unit = { 
    print(" " * indent)
    println(fa.head + " :< " + fa.tail)
    fa.tail.students.foreach(go(_, indent + 1))
  }
  go(fa, 0)
}
```

```tut
posProf(0).parseOnly(data).option.foreach(drawCofree)
```

---

class: center, middle

# Games

---

# So Why the F?

```tut:silent
case class ProfF[A](name: String, year: Int, students: List[A])
```

`ProfF` is a functor. This means we can map over it. 

```tut:silent
implicit val PersonFunctor: Functor[ProfF] =
  new Functor[ProfF] {
    def map[A, B](fa: ProfF[A])(f: A => B): ProfF[B] =
      fa.copy(students = fa.students.map(f))
  }
```

Thus.

```tut
val ps = ProfF("Bob", 1976, List("foo", "bar"))
ps.map(s => s.length)
```

---

# But wait, there's more!

```tut:silent
case class ProfF[A](name: String, year: Int, students: List[A])
```

`ProfF` is a *traversable* functor. This means we can sequence it.

```tut:silent
implicit val PersonTraverse: Traverse[ProfF] =
  new Traverse[ProfF] {
    def traverseImpl[G[_]: Applicative, A, B](fa: ProfF[A])(f: A => G[B]): G[ProfF[B]] =
      fa.students.traverse(f).map(ss => fa.copy(students = ss))
  }
```

Thus.

```tut
val p = ProfF("Bob", 1975, List(Option(1), Option(2)))
p.sequence
```

---

# (small digression)

Because "map and then sequence" is so common, we provide `traverse` which does them in one step.

```scala
fa.map(f).sequence <~> fa.traverse(f) // (1) definition of traverse
```

And we can find another identity by equational reasoning.

```scala

fa          <~> fa.map(identity)          // (2) the functor law

fa.sequence <~> fa.map(identity).sequence // by (2) above

fa.sequence <~> fa.traverse(identity)     // by (1) above
```

So when you're working with traversable functors it's nice to know both of those substitutions.


---

class: center, middle

# Can we do some SQL now?

---

# Get your doobie on

```tut:silent
// a transactor abstracts over connection pools and io-effect types
val xa = DriverManagerTransactor[IO]("org.h2.Driver", "jdbc:h2:mem:test;DB_CLOSE_DELAY=-1", "sa", "")

// a program to create the schema
val create: ConnectionIO[Int] =
  sql"""
    CREATE TABLE prof (
      id     INTEGER IDENTITY,
      parent INTEGER     NULL,
      name   VARCHAR NOT NULL,
      year   INTEGER NOT NULL,
      FOREIGN KEY(parent) REFERENCES prof(id)        
    );
  """.update.run
```

Let's init the database.

```tut
create.transact(xa).unsafePerformIO
sql"select id from prof".query[Int].list.transact(xa).unsafePerformIO
```


---

# Insert a Tree

```tut:silent
def insertNode(op: Option[Int], p: ProfF[_]): ConnectionIO[Int] =
  sql"""
    INSERT INTO prof (parent, name, year)
    VALUES ($op, ${p.name}, ${p.year})
  """.update.withUniqueGeneratedKeys("id")
```

---

# Insert a Tree

```tut:silent
def insertNode(op: Option[Int], p: ProfF[_]): ConnectionIO[Int] =
  sql"""
    INSERT INTO prof (parent, name, year)
    VALUES ($op, ${p.name}, ${p.year})
  """.update.withUniqueGeneratedKeys("id")

def insertTree(fp: Fix[ProfF], op: Option[Int]): ConnectionIO[Cofree[ProfF, Int]] =
  for {
    h <- insertNode(op, fp.unfix)       // ConnectionIO[Int] 
    t <- fp.unfix                       // ProfF[Fix[ProfF]] 
           .map(insertTree(_, Some(h))) // ProfF[ConnectionIO[Cofree[ProfF, Int]]]
           .sequence                    // ConnectionIO[ProfF[Cofree[ProfF, Int]]]
  } yield Cofree(h, t) 
```

---

# Insert a Tree

```tut:silent
def insertNode(op: Option[Int], p: ProfF[_]): ConnectionIO[Int] =
  sql"""
    INSERT INTO prof (parent, name, year)
    VALUES ($op, ${p.name}, ${p.year})
  """.update.withUniqueGeneratedKeys("id")

def insertTree(fp: Fix[ProfF], op: Option[Int]): ConnectionIO[Cofree[ProfF, Int]] =
  for {
    h <- insertNode(op, fp.unfix)
    t <- fp.unfix
           .traverse(insertTree(_, Some(h))) // same as map + sequence
  } yield Cofree(h, t) 
```

---

# Insert a Tree

```tut:invisible
// redefine due to shadowing
case class ProfF[A](name: String, year: Int, students: List[A]) {
  override def toString = s"ProfF($name, $year, «${students.length}»)"
}
implicit val PersonTraverse: Traverse[ProfF] =
  new Traverse[ProfF] {
    def traverseImpl[G[_]: Applicative, A, B](fa: ProfF[A])(f: A => G[B]): G[ProfF[B]] =
      fa.students.traverse(f).map(ss => fa.copy(students = ss))
  }
```

```tut:silent
def insertNode(op: Option[Int], p: ProfF[_]): ConnectionIO[Int] =
  sql"""
    INSERT INTO prof (parent, name, year)
    VALUES ($op, ${p.name}, ${p.year})
  """.update.withUniqueGeneratedKeys("id")

def insertTree(fp: Fix[ProfF], op: Option[Int]): ConnectionIO[Cofree[ProfF, Int]] =
  for {
    h <- insertNode(op, fp.unfix)
    t <- fp.unfix.traverse(insertTree(_, Some(h)))
  } yield Cofree(h, t) 
```

---

# Insert a Tree

```tut:invisible
// redefine due to shadowing

def prof(n: Int): Parser[Fix[ProfF]] =
  for {
    _    <- manyN(n, char(' '))   
    name <- stringOf(notChar(','))
    _    <- token(char(','))      
    year <- int                   
    _    <- char('\n')            
    ss   <- many(prof(n + 2))     
  } yield Fix(ProfF(name, year, ss))

def ioDrawCofree[F[_]: Traverse, A](fa: Cofree[F, A], indent: Int = 0): IO[Unit] = 
  for {
    _ <- IO(print(" " * indent))
    _ <- IO(println(fa.head + " :< " + fa.tail))
    _ <- fa.tail.traverse(ioDrawCofree(_, indent + 1))
  } yield ()
```

```tut
val p = prof(0).parseOnly(data).option.get // yolo
val io = insertTree(p, None).transact(xa).flatMap(c => ioDrawCofree(c))
io.unsafePerformIO
```

---

# Insert a Tree

```tut
io.unsafePerformIO
```

---

# And now read it back.

```tut:silent
def readNode(id: Int): ConnectionIO[ProfF[Int]] =
  for {
    d  <- sql"SELECT name, year FROM prof WHERE id = $id".query[(String, Int)].unique
    ss <- sql"SELECT id FROM prof WHERE parent = $id".query[Int].list
  } yield ProfF(d._1, d._2, ss)
```
---


# And now read it back.

```tut:silent
def readNode(id: Int): ConnectionIO[ProfF[Int]] =
  for {
    d  <- sql"SELECT name, year FROM prof WHERE id = $id".query[(String, Int)].unique
    ss <- sql"SELECT id FROM prof WHERE parent = $id".query[Int].list
  } yield ProfF(d._1, d._2, ss)

def readTree(id: Int): ConnectionIO[Cofree[ProfF, Int]] =
  readNode(id).flatMap { pi =>
    pi.map(readTree)      // ProfF[ConnectionIO[Cofree[ProfF, Int]]]
      .sequence           // ConnectionIO[ProfF[Cofree[ProfF, Int]]]
      .map(Cofree(id, _)) // ConnectionIO[Cofree[ProfF, Int]]
  }
```

---

# And now read it back.

```tut:silent
def readNode(id: Int): ConnectionIO[ProfF[Int]] =
  for {
    d  <- sql"SELECT name, year FROM prof WHERE id = $id".query[(String, Int)].unique
    ss <- sql"SELECT id FROM prof WHERE parent = $id".query[Int].list
  } yield ProfF(d._1, d._2, ss)

def readTree(id: Int): ConnectionIO[Cofree[ProfF, Int]] =
  readNode(id).flatMap { pi =>
    pi.traverse(readTree)
      .map(Cofree(id, _))
  }
```

---

# And now read it back.

```tut:silent
def readNode(id: Int): ConnectionIO[ProfF[Int]] =
  for {
    d  <- sql"SELECT name, year FROM prof WHERE id = $id".query[(String, Int)].unique
    ss <- sql"SELECT id FROM prof WHERE parent = $id".query[Int].list
  } yield ProfF(d._1, d._2, ss)

def readTree(id: Int): ConnectionIO[Cofree[ProfF, Int]] =
  readNode(id).flatMap(_.traverse(readTree).map(Cofree(id, _)))
```


---

# (another digression)

```tut:silent
// our original method for reading a tree
def readTree(id: Int): ConnectionIO[Cofree[ProfF, Int]] =
  readNode(id).flatMap(_.traverse(readTree).map(Cofree(id, _)))
```


---

# (another digression)

```tut:silent
// factor out the function we're calling
def readTree(id: Int)(f: Int => ConnectionIO[ProfF[Int]]): ConnectionIO[Cofree[ProfF, Int]] =
  f(id).flatMap(_.traverse(readTree(_)(f)).map(Cofree(id, _)))
```


---

# (another digression)

```tut:silent
// factor out the monad
def readTree[M[_]: Monad](id: Int)(f: Int => M[ProfF[Int]]): M[Cofree[ProfF, Int]] =
  f(id).flatMap(_.traverse(readTree(_)(f)).map(Cofree(id, _)))
```


---

# (another digression)

```tut:silent
// factor out the traversable functor
def readTree[M[_]: Monad, F[_]: Traverse](id: Int)(f: Int => M[F[Int]]): M[Cofree[F, Int]] =
  f(id).flatMap(_.traverse(readTree(_)(f)).map(Cofree(id, _)))
```


---

# (another digression)

```tut:silent
// factor out the Int
def readTree[M[_]: Monad, F[_]: Traverse, A](a: A)(f: A => M[F[A]]): M[Cofree[F, A]] =
  f(a).flatMap(_.traverse(readTree(_)(f)).map(Cofree(a, _)))
```


---

# (another digression)

```tut:silent
// we now have a generic monadic unfold into cofree
def unfoldCM[M[_]: Monad, F[_]: Traverse, A](a: A)(f: A => M[F[A]]): M[Cofree[F, A]] =
  f(a).flatMap(_.traverse(unfoldCM(_)(f)).map(Cofree(a, _)))
```


---

# (another digression)

```tut:silent
// we now have a generic monadic unfold into cofree
def unfoldCM[M[_]: Monad, F[_]: Traverse, A](a: A)(f: A => M[F[A]]): M[Cofree[F, A]] =
  f(a).flatMap(_.traverse(unfoldCM(_)(f)).map(Cofree(a, _)))

// and we can define readTree in terms of it
// we're using a totally generic corecursive unfold to do database programming, which is kind of cool
def readTree(id: Int): ConnectionIO[Cofree[ProfF, Int]] =
  unfoldCM(id)(readNode)
```

---

# Do it work?

Let's read Hilbert's sub-tree (id = 32).

```tut
val io = readTree(32).transact(xa).flatMap(c => ioDrawCofree(c))
io.unsafePerformIO
```


---

# Review

- We learned about some recursive types.
- We used them to do something useful.
- We did some equational reasoning.
- We were not frightened.

---

class: center, middle

# Thanks!
Code and slides at `tpolecat/cofree` on GitHub

## Questions?

















 </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
